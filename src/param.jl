export create_paramop, apply_paramop!

create_paramop(paramKd::AbsArrComplex,  # material parameter array
               gt₀::AbsVec{GridType},  # grid type of voxel corners; generated by ft2gt.(ft, boundft)
               N::AbsVecInteger,  # size of grid
               ∆l::NTuple{K,AbsVecNumber},  # line segments to multiply with; vectors of length N
               ∆l′⁻¹::Tuple{Vararg{AbsVecNumber}},  # inverse of line segments to divide by; vectors of length N
               isbloch::AbsVecBool,  # for K = 3, boundary conditions in x, y, z
               e⁻ⁱᵏᴸ::AbsVecNumber=ones(K);  # for K = 3, Bloch phase factor in x, y, z
               order_cmpfirst::Bool=true  # true to use Cartesian-component-major ordering for more tightly banded matrix
               ) where {K} =
    create_paramop(paramKd, SVector{K}(gt₀), SVector{K}(N), ∆l, ∆l′⁻¹, SVector{K}(isbloch), SVector{K}(e⁻ⁱᵏᴸ), order_cmpfirst=order_cmpfirst)

# Below, N can be retrieved from the size of paramKd or ∆l, but I pass it to make the size
# more explicit.  This also makes the argument list similar to create_mean()'s, which
# includes N because it allows omitting ∆l and ∆l′ and using ∆l = ∆l′ = ones.((N...,)) as
# the default arguments.
function create_paramop(paramKd::AbsArrComplex{K₊₂},  # material parameter array
                        gt₀::SVector{K,GridType},  # grid type of voxel corners; generated by ft2gt.(ft, boundft)
                        N::SInt{K},  # size of grid
                        ∆l::NTuple{K,AbsVecNumber},  # line segments to multiply with; vectors of length N
                        ∆l′⁻¹::Tuple{Vararg{AbsVecNumber}},  # inverse of line segments to divide by; vectors of length N
                        isbloch::SBool{K},  # for K = 3, boundary conditions in x, y, z
                        e⁻ⁱᵏᴸ::SNumber{K};  # for K = 3, Bloch phase factor in x, y, z
                        order_cmpfirst::Bool=true  # true to use Cartesian-component-major ordering for more tightly banded matrix
                        ) where {K,K₊₂}
    @assert K₊₂==K+2

    Kf = size(paramKd, K+1)  # field dimension
    @assert size(paramKd,K+2)==Kf

    M = prod(N)  # number voxels

    if Kf==1  # material parameter is scalar
        kdiag = 0
        paramop = create_paramop_supdiag(paramKd, kdiag, N, order_cmpfirst=order_cmpfirst)  # diagonal components of material parameter tensor
    else  # Kf ≥ 2; material parameter is tensorial
        # Following Oskooi et al.'s 2009 Optics Letters paper, off-diagonal entries of
        # material parameter tensors (e.g., ε) are evaluated at the corners of voxels whose
        # edges are field lines (e.g., E).  Therefore, if w-normal voxel faces are primal
        # grid planes, the w-component of the input fields need to be averaged in the
        # backward direction to be interpolated at voxel corners.
        #
        # Once these interpolated input fields (e.g., Ex) are multiplied with off-diagonal
        # entries (e.g., εzx) of the material parameter tensor, we get the output fields
        # (e.g., Dzx of Dz = Dzx + Dzy + Dzz = εzx Ex + εzy Ey + εzz Ez) in the direction
        # normal (say v-direction) to the input fields.  These output fields are still at
        # the voxel corners.  Now, if the v-normal voxel faces are primal grid planes, the
        # v-component of the output fields need to be averaged in the forward direction to
        # be interpolated at voxel edges.
        #
        # In summary,
        #
        # - to obtain the fields to feed to the off-diagonal entries of material parameter
        # tensors, the w-component of the input fields need to be forward(backward)-averaged
        # along the w-direction if the w-normal voxel faces are dual (primal) grid planes,
        #
        # - to distribute the resulting output fields in the v(≠w)-direction back to voxel
        # edges, the output fields need to be forward(backward)-averaged along the
        # v-direction if the v-normal voxel faces are primal (dual) grid planes.
        #
        # This means if the w-boundaries are E-field boundaries,
        # - the input E(H)w-field needs to be backward(forward)-averaged in the w-direction,
        # - the output E(H)w-field needs to be forward(backward)-averaged in the w-direction.
        isfwd_in = gt₀.==DUAL  # SBool{K}; true if input fields need to be forward-averaged
        isfwd_out = gt₀.==PRIM  # SBool{K}; true if output fields need to be backward-averaged

        # For the output averaging, ∆l and ∆l′ are not supplied to create_mean in order to
        # create a simple arithmetic averaging operator.  This is because the area factor matrix
        # multiplied for symmetry to the left of the material parameter matrix multiplies the
        # same area factor to the two fields being averaged.  (See my notes on Jul/18/2018 in
        # MaxwellFDM in Agenda.)
        Mout = create_mean(isfwd_out, N, isbloch, e⁻ⁱᵏᴸ, order_cmpfirst=order_cmpfirst)

        # For the input averaging, ∆l and ∆l′ are supplied to create min in order to create
        # a line integral averaging operator.  This is because the inverse of the length
        # factor matrix multiplied for symmetry to the right of the material parameter
        # matrix divides the two fields being averaged by different (= nonuniform) line
        # segments.  The ∆l factors multiplied inside create_minfo cancel the effect of this
        # multiplication with the nonuniform line segments.  (See my notes on Jul/18/2018 in
        # MaxwellFDM in Agenda.)
        Min = create_mean(isfwd_in, N, ∆l, ∆l′⁻¹, isbloch, e⁻ⁱᵏᴸ, order_cmpfirst=order_cmpfirst)

        # Off-diagonal components of material parameter tensor
        # Min and Mout are block-diagonal matrices, but create_paramop_supdiag() generates
        # block-off-diagonal matrices for 1 ≤ kdiag ≤ Kf-1.  See my bullet point entitled
        # [Update (May/13/2018)] in RN - Subpixel Smoothing.
        kdiag = 1
        paramop = create_paramop_supdiag(paramKd, kdiag, N, order_cmpfirst=order_cmpfirst)
        for kdiag = 2:Kf-1  # index of diagonal of material parameter tensor
            paramop += create_paramop_supdiag(paramKd, kdiag, N, order_cmpfirst=order_cmpfirst)
        end
        paramop = Mout * paramop * Min

        # Diagonal components of material parameter tensor
        kdiag = 0
        paramop += create_paramop_supdiag(paramKd, kdiag, N, order_cmpfirst=order_cmpfirst)  # diagonal components of material parameter tensor
    end

    return paramop
end

# Create the kth superdiagonal components of the parameter operator (0 ≤ k ≤ Kf-1)
#
# About the meaning of kdiag
#
# Suppose material parameter tensor is Kf-by-Kf.  Different values of kdiag take different
# entries of the material parameter tensor and used to create a matrix.  For Kf = 3, here
# are the entries (indicated by X) taken for the three different values of kdiag.
#
# kdiag = 0:
# ⎡X O O⎤
# ⎢O X O⎥
# ⎣O O X⎦
#
# kdiag = 1:
# ⎡O X O⎤
# ⎢O O X⎥
# ⎣X O O⎦
#
# kdiag = 2 (= Kf-1):
# ⎡O O X⎤
# ⎢X O O⎥
# ⎣O X O⎦
#
# So, kdiag is the index counted from the main diagonal (kdiag = 0) along the superdiagonal
# direction.  See RN - Subpixel Smoothing > [Update (May/13/2018)].  Note that if the X is
# the vw-block, then it is constructed with the vw-component of the material parameter (e.g.,
# for ε, if X is the xy-block, then it is constructed with εxy).  Therefore, whether the
# direction of the superdiagonal shift is along the row- or column-direction is not relevant.
function create_paramop_supdiag(paramKd::AbsArrComplex{K₊₂},  # size of last two dimensions is Kf-by-Kf
                                kdiag::Integer,  # 0 ≤ kdiag ≤ Kf-1; index of diagonal of material parameter tensor to set (kdiag = 0: main diagonal)
                                N::SInt{K};  # size of grid
                                order_cmpfirst::Bool=true  # true to use Cartesian-component-major ordering for more tightly banded matrix
                                ) where {K,K₊₂}
    @assert K₊₂==K+2

    Kf = size(paramKd, K+1)  # field dimension
    @assert size(paramKd,K+2)==Kf

    # Note that paramKd's i, j, k indices run from 1 to N+1 rather than to N, so we should
    # not iterate those indices from 1 to end (= N+1).
    M = prod(N)  # number of voxels
    KfM = Kf * M
    I = VecInt(undef, KfM)
    J = VecInt(undef, KfM)
    V = VecComplex(undef, KfM)
    n = 0

    CI = CartesianIndices(N.data)
    LI = LinearIndices(N.data)
    for nv = 1:Kf  # row index of material parameter tensor
        istr, ioff = order_cmpfirst ? (Kf, nv-Kf) : (1, M*(nv-1))  # (row stride, row offset)
        nw = mod1(nv+kdiag, Kf)  # column index of material parameter tensor
        jstr, joff = order_cmpfirst ? (Kf, nw-Kf) : (1, M*(nw-1))  # (column stride, column offset)
        for ci = CI
            n += 1
            @inbounds ind = LI[ci]  # linear index of Yee's cell

            I[n] = istr * ind + ioff
            J[n] = jstr * ind + joff
            @inbounds V[n] = paramKd[ci,nv,nw]
        end
    end

    return sparse(I, J, V, KfM, KfM)
end


function apply_paramop!(G::AbsArrNumber{K₊₁},  # output field; in 3D, G[i,j,k,w] is w-component of G at (i,j,k)
                        F::AbsArrNumber{K₊₁},  # input field; in 3D, F[i,j,k,w] is w-component of F at (i,j,k)
                        G′::AbsArrNumber{K₊₁},  # first temporary storage for intermediate output; in 3D, G′[i,j,k,w] is w-component of G′ at (i,j,k)
                        G′′::AbsArrNumber{K₊₁},  # second temporary storage for intermediate output; in 3D, G′[i,j,k,w] is w-component of G′ at (i,j,k)
                        ::Val{OP},  # Val(:(=)) or Val(:(+=)): set (=) or add (+=) operator to use
                        paramKd::AbsArrComplex{K₊₂},  # material parameter array
                        gt₀::SVector{K,GridType},  # grid type of voxel corners; generated by ft2gt.(ft, boundft)
                        ∆l::NTuple{K,AbsVecNumber},  # line segments to multiply with; vectors of length N
                        ∆l′⁻¹::NTuple{K,AbsVecNumber},  # line segments to divide by; vectors of length N
                        isbloch::SBool{K},  # for K = 3, boundary conditions in x, y, z
                        e⁻ⁱᵏᴸ::SNumber{K};  # for K = 3, Bloch phase factor in x, y, z
                        α::Number=1.0  # scale factor to multiply to result before adding it to G: G += α param F
                        ) where {K,K₊₁,K₊₂,OP}
    @assert K₊₁==K+1 && K₊₂==K+2

    Kf = size(paramKd, K+1)  # field dimension
    @assert size(paramKd,K+2)==Kf

    if Kf==1  # material parameter is scalar
        kdiag = 0
        apply_paramop_supdiag!(G, F, Val(OP), paramKd, kdiag, α=α)  # diagonal components of material parameter tensor
    else  # Kf ≥ 2; material parameter is tensorial
        isfwd_in = gt₀.==DUAL  # SBool{K}; true if input fields need to be forward-averaged
        isfwd_out = gt₀.==PRIM  # SBool{K}; true if output fields need to be backward-averaged

        apply_mean!(G′, F, Val(:(=)), isfwd_in, ∆l, ∆l′⁻¹, isbloch, e⁻ⁱᵏᴸ)

        # Off-diagonal components of material parameter tensor
        kdiag = 1
        apply_paramop_supdiag!(G′′, G′, Val(:(=)), paramKd, kdiag)
        for kdiag = 2:Kf-1  # index of diagonal of material parameter tensor
            apply_paramop_supdiag!(G′′, G′, Val(:(+=)), paramKd, kdiag)
        end
        apply_mean!(G, G′′, Val(OP), isfwd_out, isbloch, e⁻ⁱᵏᴸ, α=α)

        # Diagonal components of material parameter tensor
        kdiag = 0
        apply_paramop_supdiag!(G, F, Val(:(+=)), paramKd, kdiag, α=α)
    end

    return nothing
end

# 3D
function apply_paramop_supdiag!(G::AbsArrNumber{4},  # output field; G[i,j,k,w] is w-component of G at (i,j,k)
                                F::AbsArrNumber{4},  # input field; F[i,j,k,w] is w-component of F at (i,j,k)
                                ::Val{OP},  # Val(:(=)) or Val(:(+=)): set (=) or add (+=) operator to use
                                paramKd::AbsArrComplex{5},  # size of last two dimensions is Kf-by-Kf
                                kdiag::Integer;  # 0 ≤ kdiag ≤ Kf-1; index of diagonal of material parameter tensor to set (kdiag = 0: main diagonal)
                                α::Number=1.0  # scale factor to multiply to result before adding it to G: G += α param F
                                ) where {OP}
    Nx, Ny, Nz, Kf = size(G)  # Kf: field dimension
    @assert size(paramKd)[end] == size(paramKd)[end-1] == Kf

    for nv = 1:Kf  # row index of material parameter tensor
        Gv = @view G[:,:,:,nv]
        nw = mod1(nv+kdiag, Kf)  # column index of material parameter tensor
        @threads for k = 1:Nz
            for j = 1:Ny, i = 1:Nx
                @inbounds set_or_add!(Gv, (i,j,k), paramKd[i,j,k,nv,nw] * F[i,j,k,nw], Val(OP))
                # @inbounds set_or_add!(G, (i,j,k,nv), paramKd[i,j,k,nv,nw] * F[i,j,k,nw], Val(OP))
            end
        end
    end

    return nothing
end

# 2D
function apply_paramop_supdiag!(G::AbsArrNumber{3},  # output field; G[i,j,w] is w-component of G at (i,j)
                                F::AbsArrNumber{3},  # input field; F[i,j,w] is w-component of F at (i,j)
                                ::Val{OP},  # Val(:(=)) or Val(:(+=)): set (=) or add (+=) operator to use
                                paramKd::AbsArrComplex{4},  # size of last two dimensions is Kf-by-Kf
                                kdiag::Integer;  # 0 ≤ kdiag ≤ Kf-1; index of diagonal of material parameter tensor to set (kdiag = 0: main diagonal)
                                α::Number=1.0  # scale factor to multiply to result before adding it to G: G += α param F
                                ) where {OP}
    Nx, Ny, Kf = size(G)  # Kf: field dimension
    @assert size(paramKd)[end] == size(paramKd)[end-1] == Kf

    for nv = 1:Kf  # row index of material parameter tensor
        Gv = @view G[:,:,nv]
        nw = mod1(nv+kdiag, Kf)  # column index of material parameter tensor
        @threads for j = 1:Ny
            for i = 1:Nx
                @inbounds set_or_add!(Gv, (i,j), paramKd[i,j,nv,nw] * F[i,j,nw], Val(OP))
                # @inbounds set_or_add!(G, (i,j,k,nv), paramKd[i,j,k,nv,nw] * F[i,j,k,nw], Val(OP))
            end
        end
    end

    return nothing
end

# 1D
function apply_paramop_supdiag!(G::AbsArrNumber{2},  # output field; G[i,w] is w-component of G at (i,)
                                F::AbsArrNumber{2},  # input field; F[i,w] is w-component of F at (i,)
                                ::Val{OP},  # Val(:(=)) or Val(:(+=)): set (=) or add (+=) operator to use
                                paramKd::AbsArrComplex{3},  # size of last two dimensions is Kf-by-Kf
                                kdiag::Integer;  # 0 ≤ kdiag ≤ Kf-1; index of diagonal of material parameter tensor to set (kdiag = 0: main diagonal)
                                α::Number=1.0  # scale factor to multiply to result before adding it to G: G += α param F
                                ) where {OP}
    Nx, Kf = size(G)  # Kf: field dimension
    @assert size(paramKd)[end] == size(paramKd)[end-1] == Kf

    for nv = 1:Kf  # row index of material parameter tensor
        Gv = @view G[:,:,nv]
        nw = mod1(nv+kdiag, Kf)  # column index of material parameter tensor
        @threads for j = 1:Ny
            for i = 1:Nx
                @inbounds set_or_add!(Gv, (i,j), paramKd[i,j,nv,nw] * F[i,j,nw], Val(OP))
                # @inbounds set_or_add!(G, (i,j,k,nv), paramKd[i,j,k,nv,nw] * F[i,j,k,nw], Val(OP))
            end
        end
    end

    return nothing
end

# function apply_paramop_supdiag!(G::AbsArrNumber{K₊₁},  # output field; in 3D, G[i,j,k,w] is w-component of G at (i,j,k)
#                                 F::AbsArrNumber{K₊₁},  # input field; in 3D, F[i,j,k,w] is w-component of F at (i,j,k)
#                                 ::Val{OP},  # Val(:(=)) or Val(:(+=)): set (=) or add (+=) operator to use
#                                 paramKd::AbsArrComplex{K₊₂},  # size of last two dimensions is Kf-by-Kf
#                                 kdiag::Integer;  # 0 ≤ kdiag ≤ Kf-1; index of diagonal of material parameter tensor to set (kdiag = 0: main diagonal)
#                                 α::Number=1.0  # scale factor to multiply to result before adding it to G: G += α param F
#                                 ) where {K₊₁,K₊₂,OP}
#     K = K₊₁ - 1
#     @assert K₊₂==K+2
#
#     Kf = size(paramKd, K+1)  # field dimension
#     @assert size(paramKd,K+2)==Kf
#
#     CI = CartesianIndices(size(G)[1:K])
#     for nv = 1:Kf  # row index of material parameter tensor
#         nw = mod1(nv+kdiag, Kf)  # column index of material parameter tensor
#         for ci = CI
#             @inbounds G[ci,nv] = paramKd[ci,nv,nw] * F[ci,nw]
#         end
#     end
#
#     return nothing
# end
